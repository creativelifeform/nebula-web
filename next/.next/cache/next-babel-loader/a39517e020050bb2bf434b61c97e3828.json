{"ast":null,"code":"import _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport * as THREE from 'three';\nimport ParticleSystem, { SpriteRenderer } from 'three-nebula';\nimport { test as DEFAULT_DATA } from './data.js';\nconst {\n  PerspectiveCamera,\n  Scene,\n  WebGLRenderer\n} = THREE;\n/**\n * Sets up three js and particle system environment so that they can be rendered\n * into the editor's Stage component.\n *\n */\n\nexport class Visualisation {\n  constructor(canvas, data = DEFAULT_DATA) {\n    this.canvas = canvas;\n    this.data = data;\n    this.shouldAnimate = true;\n  }\n  /**\n   * Starts the visualization.\n   *\n   * @return {Promise<Visualization>}\n   */\n\n\n  start() {\n    this.shouldAnimate = true;\n    return this.makeScene().makeCamera().makeWebGlRenderer().makeParticleSystem();\n  }\n  /**\n   * Stops the visualisation.\n   *\n   * @return void\n   */\n\n\n  stop() {\n    this.shouldAnimate = false;\n    this.particleSystem.destroy();\n  }\n  /**\n   * Renders the visualization.\n   *\n   * @return {Visualization}\n   */\n\n\n  render() {\n    const animate = () => {\n      if (!this.shouldAnimate) {\n        return;\n      }\n\n      requestAnimationFrame(animate);\n      this.particleSystem.update();\n      this.webGlRenderer.render(this.scene, this.camera);\n    };\n\n    animate();\n    return this;\n  }\n\n  resize() {\n    const {\n      camera,\n      webGlRenderer,\n      canvas: {\n        clientWidth,\n        clientHeight\n      }\n    } = this;\n    camera.aspect = clientWidth / clientHeight;\n    camera.updateProjectionMatrix();\n    webGlRenderer.setSize(clientWidth, clientHeight, false);\n  }\n\n  makeScene() {\n    this.scene = new Scene();\n    return this;\n  }\n\n  makeCamera() {\n    const cameraState = {\n      type: 'PerspectiveCamera',\n      params: {\n        fov: 75,\n        nearPlane: 0.1,\n        farPlane: 1000\n      },\n      position: {\n        x: -10,\n        y: 0,\n        z: 50\n      },\n      rotation: {\n        x: 0,\n        y: 0,\n        z: 0\n      },\n      controller: {\n        enabled: true\n      }\n    };\n    const {\n      canvas: {\n        clientWidth,\n        clientHeight\n      }\n    } = this;\n    const {\n      params,\n      position,\n      rotation\n    } = cameraState;\n    const {\n      fov,\n      nearPlane,\n      farPlane\n    } = params;\n    this.camera = new PerspectiveCamera(fov, clientWidth / clientHeight, nearPlane, farPlane);\n    this.camera.position.copy(position);\n    this.camera.rotation.set(rotation.x, rotation.y, rotation.z);\n    return this;\n  }\n\n  makeWebGlRenderer(options = {\n    alpha: true,\n    antialias: true\n  }) {\n    const {\n      canvas,\n      canvas: {\n        clientWidth,\n        clientHeight\n      }\n    } = this;\n    this.webGlRenderer = this.webGlRenderer || new WebGLRenderer(_objectSpread({\n      canvas\n    }, options));\n    this.webGlRenderer.setSize(clientWidth, clientHeight, false);\n    return this;\n  }\n\n  makeParticleSystem() {\n    return new _Promise(resolve => {\n      ParticleSystem.fromJSONAsync(this.data.particleSystemState, THREE).then(particleSystem => {\n        this.particleSystem = particleSystem;\n        particleSystem.addRenderer(new SpriteRenderer(this.scene, THREE));\n        return resolve(this.render());\n      }).catch(console.error);\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/rohandeshpande/Projects/nebula-web/next/pages/home/Hero/Canvas/Visualisation/index.js"],"names":["THREE","ParticleSystem","SpriteRenderer","test","DEFAULT_DATA","PerspectiveCamera","Scene","WebGLRenderer","Visualisation","constructor","canvas","data","shouldAnimate","start","makeScene","makeCamera","makeWebGlRenderer","makeParticleSystem","stop","particleSystem","destroy","render","animate","requestAnimationFrame","update","webGlRenderer","scene","camera","resize","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","cameraState","type","params","fov","nearPlane","farPlane","position","x","y","z","rotation","controller","enabled","copy","set","options","alpha","antialias","resolve","fromJSONAsync","particleSystemState","then","addRenderer","catch","console","error"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,OAAOC,cAAP,IAAyBC,cAAzB,QAA+C,cAA/C;AAEA,SAASC,IAAI,IAAIC,YAAjB,QAAqC,WAArC;AAEA,MAAM;AAAEC,EAAAA,iBAAF;AAAqBC,EAAAA,KAArB;AAA4BC,EAAAA;AAA5B,IAA8CP,KAApD;AAEA;;;;;;AAKA,OAAO,MAAMQ,aAAN,CAAoB;AACzBC,EAAAA,WAAW,CAACC,MAAD,EAASC,IAAI,GAAGP,YAAhB,EAA8B;AACvC,SAAKM,MAAL,GAAcA,MAAd;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,aAAL,GAAqB,IAArB;AACD;AAED;;;;;;;AAKAC,EAAAA,KAAK,GAAG;AACN,SAAKD,aAAL,GAAqB,IAArB;AAEA,WAAO,KAAKE,SAAL,GACJC,UADI,GAEJC,iBAFI,GAGJC,kBAHI,EAAP;AAID;AAED;;;;;;;AAKAC,EAAAA,IAAI,GAAG;AACL,SAAKN,aAAL,GAAqB,KAArB;AACA,SAAKO,cAAL,CAAoBC,OAApB;AACD;AAED;;;;;;;AAKAC,EAAAA,MAAM,GAAG;AACP,UAAMC,OAAO,GAAG,MAAM;AACpB,UAAI,CAAC,KAAKV,aAAV,EAAyB;AACvB;AACD;;AAEDW,MAAAA,qBAAqB,CAACD,OAAD,CAArB;AAEA,WAAKH,cAAL,CAAoBK,MAApB;AACA,WAAKC,aAAL,CAAmBJ,MAAnB,CAA0B,KAAKK,KAA/B,EAAsC,KAAKC,MAA3C;AACD,KATD;;AAWAL,IAAAA,OAAO;AAEP,WAAO,IAAP;AACD;;AAEDM,EAAAA,MAAM,GAAG;AACP,UAAM;AACJD,MAAAA,MADI;AAEJF,MAAAA,aAFI;AAGJf,MAAAA,MAAM,EAAE;AAAEmB,QAAAA,WAAF;AAAeC,QAAAA;AAAf;AAHJ,QAIF,IAJJ;AAMAH,IAAAA,MAAM,CAACI,MAAP,GAAgBF,WAAW,GAAGC,YAA9B;AACAH,IAAAA,MAAM,CAACK,sBAAP;AACAP,IAAAA,aAAa,CAACQ,OAAd,CAAsBJ,WAAtB,EAAmCC,YAAnC,EAAiD,KAAjD;AACD;;AAEDhB,EAAAA,SAAS,GAAG;AACV,SAAKY,KAAL,GAAa,IAAIpB,KAAJ,EAAb;AAEA,WAAO,IAAP;AACD;;AAEDS,EAAAA,UAAU,GAAG;AACX,UAAMmB,WAAW,GAAG;AAClBC,MAAAA,IAAI,EAAE,mBADY;AAElBC,MAAAA,MAAM,EAAE;AACNC,QAAAA,GAAG,EAAE,EADC;AAENC,QAAAA,SAAS,EAAE,GAFL;AAGNC,QAAAA,QAAQ,EAAE;AAHJ,OAFU;AAOlBC,MAAAA,QAAQ,EAAE;AACRC,QAAAA,CAAC,EAAE,CAAC,EADI;AAERC,QAAAA,CAAC,EAAE,CAFK;AAGRC,QAAAA,CAAC,EAAE;AAHK,OAPQ;AAYlBC,MAAAA,QAAQ,EAAE;AACRH,QAAAA,CAAC,EAAE,CADK;AAERC,QAAAA,CAAC,EAAE,CAFK;AAGRC,QAAAA,CAAC,EAAE;AAHK,OAZQ;AAiBlBE,MAAAA,UAAU,EAAE;AACVC,QAAAA,OAAO,EAAE;AADC;AAjBM,KAApB;AAqBA,UAAM;AACJpC,MAAAA,MAAM,EAAE;AAAEmB,QAAAA,WAAF;AAAeC,QAAAA;AAAf;AADJ,QAEF,IAFJ;AAGA,UAAM;AAAEM,MAAAA,MAAF;AAAUI,MAAAA,QAAV;AAAoBI,MAAAA;AAApB,QAAiCV,WAAvC;AACA,UAAM;AAAEG,MAAAA,GAAF;AAAOC,MAAAA,SAAP;AAAkBC,MAAAA;AAAlB,QAA+BH,MAArC;AAEA,SAAKT,MAAL,GAAc,IAAItB,iBAAJ,CACZgC,GADY,EAEZR,WAAW,GAAGC,YAFF,EAGZQ,SAHY,EAIZC,QAJY,CAAd;AAOA,SAAKZ,MAAL,CAAYa,QAAZ,CAAqBO,IAArB,CAA0BP,QAA1B;AACA,SAAKb,MAAL,CAAYiB,QAAZ,CAAqBI,GAArB,CAAyBJ,QAAQ,CAACH,CAAlC,EAAqCG,QAAQ,CAACF,CAA9C,EAAiDE,QAAQ,CAACD,CAA1D;AAEA,WAAO,IAAP;AACD;;AAED3B,EAAAA,iBAAiB,CAACiC,OAAO,GAAG;AAAEC,IAAAA,KAAK,EAAE,IAAT;AAAeC,IAAAA,SAAS,EAAE;AAA1B,GAAX,EAA6C;AAC5D,UAAM;AACJzC,MAAAA,MADI;AAEJA,MAAAA,MAAM,EAAE;AAAEmB,QAAAA,WAAF;AAAeC,QAAAA;AAAf;AAFJ,QAGF,IAHJ;AAKA,SAAKL,aAAL,GACE,KAAKA,aAAL,IAAsB,IAAIlB,aAAJ;AAAoBG,MAAAA;AAApB,OAA+BuC,OAA/B,EADxB;AAEA,SAAKxB,aAAL,CAAmBQ,OAAnB,CAA2BJ,WAA3B,EAAwCC,YAAxC,EAAsD,KAAtD;AAEA,WAAO,IAAP;AACD;;AAEDb,EAAAA,kBAAkB,GAAG;AACnB,WAAO,aAAYmC,OAAO,IAAI;AAC5BnD,MAAAA,cAAc,CAACoD,aAAf,CAA6B,KAAK1C,IAAL,CAAU2C,mBAAvC,EAA4DtD,KAA5D,EACGuD,IADH,CACQpC,cAAc,IAAI;AACtB,aAAKA,cAAL,GAAsBA,cAAtB;AACAA,QAAAA,cAAc,CAACqC,WAAf,CAA2B,IAAItD,cAAJ,CAAmB,KAAKwB,KAAxB,EAA+B1B,KAA/B,CAA3B;AAEA,eAAOoD,OAAO,CAAC,KAAK/B,MAAL,EAAD,CAAd;AACD,OANH,EAOGoC,KAPH,CAOSC,OAAO,CAACC,KAPjB;AAQD,KATM,CAAP;AAUD;;AAxIwB","sourcesContent":["import * as THREE from 'three';\n\nimport ParticleSystem, { SpriteRenderer } from 'three-nebula';\n\nimport { test as DEFAULT_DATA } from './data.js';\n\nconst { PerspectiveCamera, Scene, WebGLRenderer } = THREE;\n\n/**\n * Sets up three js and particle system environment so that they can be rendered\n * into the editor's Stage component.\n *\n */\nexport class Visualisation {\n  constructor(canvas, data = DEFAULT_DATA) {\n    this.canvas = canvas;\n    this.data = data;\n    this.shouldAnimate = true;\n  }\n\n  /**\n   * Starts the visualization.\n   *\n   * @return {Promise<Visualization>}\n   */\n  start() {\n    this.shouldAnimate = true;\n\n    return this.makeScene()\n      .makeCamera()\n      .makeWebGlRenderer()\n      .makeParticleSystem();\n  }\n\n  /**\n   * Stops the visualisation.\n   *\n   * @return void\n   */\n  stop() {\n    this.shouldAnimate = false;\n    this.particleSystem.destroy();\n  }\n\n  /**\n   * Renders the visualization.\n   *\n   * @return {Visualization}\n   */\n  render() {\n    const animate = () => {\n      if (!this.shouldAnimate) {\n        return;\n      }\n\n      requestAnimationFrame(animate);\n\n      this.particleSystem.update();\n      this.webGlRenderer.render(this.scene, this.camera);\n    };\n\n    animate();\n\n    return this;\n  }\n\n  resize() {\n    const {\n      camera,\n      webGlRenderer,\n      canvas: { clientWidth, clientHeight },\n    } = this;\n\n    camera.aspect = clientWidth / clientHeight;\n    camera.updateProjectionMatrix();\n    webGlRenderer.setSize(clientWidth, clientHeight, false);\n  }\n\n  makeScene() {\n    this.scene = new Scene();\n\n    return this;\n  }\n\n  makeCamera() {\n    const cameraState = {\n      type: 'PerspectiveCamera',\n      params: {\n        fov: 75,\n        nearPlane: 0.1,\n        farPlane: 1000,\n      },\n      position: {\n        x: -10,\n        y: 0,\n        z: 50,\n      },\n      rotation: {\n        x: 0,\n        y: 0,\n        z: 0,\n      },\n      controller: {\n        enabled: true,\n      },\n    };\n    const {\n      canvas: { clientWidth, clientHeight },\n    } = this;\n    const { params, position, rotation } = cameraState;\n    const { fov, nearPlane, farPlane } = params;\n\n    this.camera = new PerspectiveCamera(\n      fov,\n      clientWidth / clientHeight,\n      nearPlane,\n      farPlane\n    );\n\n    this.camera.position.copy(position);\n    this.camera.rotation.set(rotation.x, rotation.y, rotation.z);\n\n    return this;\n  }\n\n  makeWebGlRenderer(options = { alpha: true, antialias: true }) {\n    const {\n      canvas,\n      canvas: { clientWidth, clientHeight },\n    } = this;\n\n    this.webGlRenderer =\n      this.webGlRenderer || new WebGLRenderer({ canvas, ...options });\n    this.webGlRenderer.setSize(clientWidth, clientHeight, false);\n\n    return this;\n  }\n\n  makeParticleSystem() {\n    return new Promise(resolve => {\n      ParticleSystem.fromJSONAsync(this.data.particleSystemState, THREE)\n        .then(particleSystem => {\n          this.particleSystem = particleSystem;\n          particleSystem.addRenderer(new SpriteRenderer(this.scene, THREE));\n\n          return resolve(this.render());\n        })\n        .catch(console.error);\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}